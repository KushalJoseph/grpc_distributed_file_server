each chunk is PFS_BLOCK_SIZE * STRIPE_BLOCKS = 1024 bytes


Client queries file server for write.
Client receives instructions chunks.

Client sends instruction to respective file server.
file server writes bytes to "filename_chunk_x"

#include <iostream>
#include <fstream>
#include <vector>
#include <cassert>
#include <string>

void writeBytesToFile(const std::string& filename, const char* buf, int start_byte, int end_byte) {
    assert(buf != nullptr);
    assert(end_byte - start_byte + 1 == static_cast<int>(strlen(buf)));

    std::fstream file(filename, std::ios::in | std::ios::out | std::ios::binary);

    // Check if the file exists and open successfully
    if (!file) {
        // File doesn't exist; create a new one
        file.open(filename, std::ios::out | std::ios::binary);
        if (!file) {
            std::cerr << "Error: Could not create file: " << filename << std::endl;
            return;
        }
    }

    // Determine the file size
    file.seekg(0, std::ios::end);
    int file_size = file.tellg();
    file.seekp(0, std::ios::beg); // Reset write pointer to start of the file

    // Handle cases
    if (start_byte < file_size) {
        // Overwrite part of the range if it is within the file
        file.seekp(start_byte);
        int overwrite_bytes = std::min(end_byte, file_size - 1) - start_byte + 1;
        file.write(buf, overwrite_bytes);
    }

    if (end_byte >= file_size) {
        // Extend the file if necessary
        if (file_size < start_byte) {
            // Add padding bytes (fill with zeros) between the current end of the file and the start_byte
            file.seekp(0, std::ios::end);
            std::vector<char> padding(start_byte - file_size, '\0');
            file.write(padding.data(), padding.size());
        }

        // Write new data for the extended portion
        int extend_start = std::max(file_size, start_byte);
        int extend_bytes = end_byte - extend_start + 1;
        file.seekp(extend_start);
        file.write(buf + (extend_start - start_byte), extend_bytes);
    }

    file.close();
    std::cout << "Bytes written successfully to the file." << std::endl;
}

int main() {
    const std::string filename = "example.bin";

    // Test case: Overwrite a portion of an existing file
    const char buf1[] = "HelloWorld"; // Length = 10
    writeBytesToFile(filename, buf1, 500, 509);

    // Test case: Extend the file beyond its current size
    const char buf2[] = "ExtendFileData"; // Length = 14
    writeBytesToFile(filename, buf2, 900, 913);

    return 0;
}








When the client calls read() or write() --> this is when we need to REQUEST token.
Tokens have nothing to do with Chunks.
Token distribution is completely independent.

"filename.txt" --> 200 bytes.
client1 requests read 40-69. Give. Note [40-69] reserved.
client2 requests read 60-80. Give. Note [60-]


NOTE: DONT CREATE STUB FOR EVERY REQUEST! KEEP IT GLOBAL!




If the range is free for given operation:
    Hand out range to client. Client continues. Server sends out Read/Write instructions.
If the range is not free:
        